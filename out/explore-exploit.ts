// Board representation (X - Player, O - AI, empty - '')
type Board = string[];

// Action representing a move (row, column)
type Action = { row: number; col: number };

// Reward values
const WIN_REWARD = 10;
const DRAW_REWARD = 0;
const LOSE_REWARD = -10;

class TicTacToe {
    private board: Board;
    private currentPlayer: string;
    private qValues: { [state: string]: { [action: string]: number } };

    constructor() {
        this.board = ["", "", "", "", "", "", "", "", ""];
        this.currentPlayer = "X";
        this.qValues = {};
    }

    // Reset the game
    public resetGame() {
        this.board = ["", "", "", "", "", "", "", "", ""];
        this.currentPlayer = "X";
    }

    // Get the current board state
    public getBoard(): Board {
        return [...this.board];
    }

    // Check if a player has won
    private checkWin(player: string): boolean {
        const winConditions = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
        ];

        for (const condition of winConditions) {
            if (
                this.board[condition[0]] === player &&
                this.board[condition[1]] === player &&
                this.board[condition[2]] === player
            ) {
                return true;
            }
        }
        return false;
    }

    // Check if the game is a draw
    private isDraw(): boolean {
        return this.board.every((cell) => cell !== "");
    }

    // Get available actions (empty cells)
    private getAvailableActions(): Action[] {
        const actions: Action[] = [];
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (this.board[i * 3 + j] === "") {
                    actions.push({ row: i, col: j });
                }
            }
        }
        return actions;
    }

    // Take an action and update the board
    public takeAction(action: Action) {
        this.board[action.row * 3 + action.col] = this.currentPlayer;
        this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
    }

    // Get the game reward
    private getReward(): number {
        if (this.checkWin("X")) {
            return LOSE_REWARD;
        } else if (this.checkWin("O")) {
            return WIN_REWARD;
        } else if (this.isDraw()) {
            return DRAW_REWARD;
        }
        return 0;
    }

    // Update Q-values based on experience
    private updateQValue(state: string, action: string, reward: number, nextState: string) {
        const alpha = 0.1; // Learning rate
        const gamma = 0.9; // Discount factor

        const currentQ = this.qValues[state]?.[action] || 0;
        const nextQ = Math.max(...Object.values(this.qValues[nextState] || {}));

        this.qValues[state][action] = currentQ + alpha * (reward + gamma * nextQ - currentQ);
    }

    // AI player using Q-learning to choose the best action
    public aiPlay(): Action {
        const state = this.board.join("");
        const availableActions = this.getAvailableActions();

        // Initialize Q-values for this state if not already present
        if (!this.qValues[state]) {
            this.qValues[state] = {};
            availableActions.forEach((action) => this.qValues[state][action.row + "-" + action.col]);
        }
    }
}
