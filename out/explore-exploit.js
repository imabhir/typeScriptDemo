var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
// Reward values
var WIN_REWARD = 10;
var DRAW_REWARD = 0;
var LOSE_REWARD = -10;
var TicTacToe = /** @class */ (function () {
    function TicTacToe() {
        this.board = ["", "", "", "", "", "", "", "", ""];
        this.currentPlayer = "X";
        this.qValues = {};
    }
    // Reset the game
    TicTacToe.prototype.resetGame = function () {
        this.board = ["", "", "", "", "", "", "", "", ""];
        this.currentPlayer = "X";
    };
    // Get the current board state
    TicTacToe.prototype.getBoard = function () {
        return __spreadArray([], this.board, true);
    };
    // Check if a player has won
    TicTacToe.prototype.checkWin = function (player) {
        var winConditions = [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
        ];
        for (var _i = 0, winConditions_1 = winConditions; _i < winConditions_1.length; _i++) {
            var condition = winConditions_1[_i];
            if (this.board[condition[0]] === player &&
                this.board[condition[1]] === player &&
                this.board[condition[2]] === player) {
                return true;
            }
        }
        return false;
    };
    // Check if the game is a draw
    TicTacToe.prototype.isDraw = function () {
        return this.board.every(function (cell) { return cell !== ""; });
    };
    // Get available actions (empty cells)
    TicTacToe.prototype.getAvailableActions = function () {
        var actions = [];
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 3; j++) {
                if (this.board[i * 3 + j] === "") {
                    actions.push({ row: i, col: j });
                }
            }
        }
        return actions;
    };
    // Take an action and update the board
    TicTacToe.prototype.takeAction = function (action) {
        this.board[action.row * 3 + action.col] = this.currentPlayer;
        this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
    };
    // Get the game reward
    TicTacToe.prototype.getReward = function () {
        if (this.checkWin("X")) {
            return LOSE_REWARD;
        }
        else if (this.checkWin("O")) {
            return WIN_REWARD;
        }
        else if (this.isDraw()) {
            return DRAW_REWARD;
        }
        return 0;
    };
    // Update Q-values based on experience
    TicTacToe.prototype.updateQValue = function (state, action, reward, nextState) {
        var _a;
        var alpha = 0.1; // Learning rate
        var gamma = 0.9; // Discount factor
        var currentQ = ((_a = this.qValues[state]) === null || _a === void 0 ? void 0 : _a[action]) || 0;
        var nextQ = Math.max.apply(Math, Object.values(this.qValues[nextState] || {}));
        this.qValues[state][action] = currentQ + alpha * (reward + gamma * nextQ - currentQ);
    };
    // AI player using Q-learning to choose the best action
    TicTacToe.prototype.aiPlay = function () {
        var _this = this;
        var state = this.board.join("");
        var availableActions = this.getAvailableActions();
        // Initialize Q-values for this state if not already present
        if (!this.qValues[state]) {
            this.qValues[state] = {};
            availableActions.forEach(function (action) { return _this.qValues[state][action.row + "-" + action.col]; });
        }
    };
    return TicTacToe;
}());
